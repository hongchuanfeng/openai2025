<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>XML/JSONç›¸äº’è½¬æ¢</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		body {
			background-color: #f5f5f5;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
			padding: 20px;
		}
		.nav {
			margin-bottom: 20px;
			display: flex;
			gap: 20px;
		}
		.nav-item {
			color: #666;
			text-decoration: none;
			font-size: 14px;
			display: flex;
			align-items: center;
			gap: 5px;
		}
		.container {
			background: white;
			padding: 30px;
			border-radius: 5px;
		}

		.header {
			text-align: center;
			margin-bottom: 20px;
		}

		.title {
			font-size: 24px;
			color: #4CAF50;
			margin: 0;
		}

		.stars {
			color: #FFD700;
			font-size: 20px;
			margin-top: 5px;
		}

		.editor-container {
			display: grid;
			grid-template-columns: 1fr;
			gap: 20px;
		}

		.code-area {
			position: relative;
			border: 2px solid #4CAF50;
			border-radius: 4px;
			background: white;
		}

		.line-numbers {
			position: absolute;
			left: 0;
			top: 0;
			padding: 10px;
			color: #666;
			font-family: Consolas, monospace;
			user-select: none;
		}

		textarea {
			width: 100%;
			height: 300px;
			padding: 10px 10px 10px 40px;
			border: none;
			resize: vertical;
			font-family: Consolas, monospace;
			font-size: 14px;
			line-height: 1.5;
			tab-size: 4;
		}

		.button-group {
			text-align: center;
			margin: 20px 0;
		}

		button {
			padding: 12px 24px;
			margin: 0 10px;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-weight: 500;
			transition: all 0.3s;
		}

		.xml-btn {
			background-color: #4CAF50;
			color: white;
		}

		.json-btn {
			background-color: #2196F3;
			color: white;
		}

		.clear-btn {
			background-color: #9E9E9E;
			color: white;
		}

		.error {
			color: #ff0000;
			text-align: center;
			margin: 10px 0;
			display: none;
		}
	</style>

	<script src="https://cdn.jsdelivr.net/npm/jquery"></script>
<!--	<script src="https://cdn.jsdelivr.net/npm/jquery.xml2json"></script>-->
<!--	<script src="https://cdn.jsdelivr.net/npm/xml2json"></script>-->
	<script src="https://cdn.jsdelivr.net/npm/xml2js@0.6.2/lib/xml2js.min.js"></script>

</head>
<body>
<nav class="nav">
	<a href="../index.html" class="nav-item">ğŸ” æ¨èå·¥å…·</a>
	<a href="../life.html" class="nav-item">ğŸ  ç”Ÿæ´»å·¥å…·</a>
	<a href="../encry.html" class="nav-item">ğŸ”’ åŠ å¯†è§£å¯†</a>
	<a href="../code.html" class="nav-item">ğŸ“ ç¼–ç è§£ç </a>
	<a href="../dev.html" class="nav-item">ğŸ’» å¼€å‘å·¥å…·</a>
	<a href="../image.html" class="nav-item">ğŸ–¼ï¸ å›¾ç‰‡å¤„ç†</a>
	<a href="../game.html" class="nav-item">ğŸ® å¨±ä¹å·¥å…·</a>
</nav>
<div class="container">
	<div class="header">
		<h1 class="title">XML/JSONç›¸äº’è½¬æ¢</h1>
		<div class="stars">â˜…â˜…â˜…â˜…â˜…</div>
	</div>

	<div class="editor-container">
		<div class="code-area">
			<div class="line-numbers" id="xmlLines"></div>
			<textarea id="xmlInput" spellcheck="false">
<sites>
    <site>
        <name>xiaohong</name>
        <age>18</age>
    </site>
    <site>
        <name>xiaoming</name>
        <age>24</age>
    </site>
</sites></textarea>
		</div>

		<div class="button-group">
			<button class="xml-btn" onclick="xmlToJson()">XMLè½¬JSON â†“</button>
			<button class="json-btn" onclick="convertJsonToXml()">JSONè½¬XML â†‘</button>
			<button class="clear-btn" onclick="clearAll()">æ¸…ç©º</button>
		</div>

		<div class="code-area">
			<div class="line-numbers" id="jsonLines"></div>
			<textarea id="jsonInput" spellcheck="false"></textarea>
		</div>

		<div class="error" id="errorMsg"></div>
	</div>

	<script>
		// åŠ¨æ€è¡Œå·æ›´æ–°
		function updateLineNumbers(textareaId, linesId) {
			const textarea = document.getElementById(textareaId);
			const lines = textarea.value.split('\n').length;
			document.getElementById(linesId).innerHTML = Array(lines).fill('<span></span>').join('\n');
		}

		function xmlToJson66(xmlStr) {
			const parser = new DOMParser();
			const xmlDoc = parser.parseFromString(xmlStr, "text/xml");

			function traverse(node) {
				const obj = {};
				// å¤„ç†å±æ€§
				if (node.attributes?.length > 0) {
					obj["@attributes"] = {};
					Array.from(node.attributes).forEach(attr => {
						obj["@attributes"][attr.name] = attr.value;
					});
				}
				// å¤„ç†å­èŠ‚ç‚¹
				Array.from(node.children).forEach(child => {
					const childName = child.tagName;
					const childData = traverse(child);
					obj[childName] = childData;
				});
				// å¤„ç†æ–‡æœ¬å†…å®¹
				if (node.childNodes.length === 1 && node.childNodes[0].nodeType === 3) {
					return node.childNodes[0].nodeValue.trim();
				}
				return Object.keys(obj).length ? obj : null;
			}

			return traverse(xmlDoc.documentElement);
		}
		function xmlToJson77(xmlStr) {
			const parser = new DOMParser();
			const xmlDoc = parser.parseFromString(xmlStr, "text/xml");

			function traverse(node) {
				// å¤„ç†æ³¨é‡Šã€CDATAç­‰éå…ƒç´ èŠ‚ç‚¹
				if (node.nodeType !== Node.ELEMENT_NODE) {
					return node.nodeValue?.trim() || null;
				}

				const obj = {};

				// å¤„ç†å±æ€§ï¼ˆç½‘é¡µ7æ–¹æ¡ˆå¢å¼ºï¼‰
				if (node.attributes.length > 0) {
					obj["@attributes"] = {};
					Array.from(node.attributes).forEach(attr => {
						obj["@attributes"][attr.name] = attr.value;
					});
				}

				// å¤„ç†å­èŠ‚ç‚¹é€’å½’ï¼ˆå…³é”®æ”¹è¿›ç‚¹ï¼‰
				const childNodes = Array.from(node.childNodes);
				childNodes.forEach(child => {
					const childName = child.nodeName.toLowerCase();
					const childData = traverse(child);

					if (childData === null) return; // å¿½ç•¥ç©ºèŠ‚ç‚¹

					// å¤„ç†æ··åˆå†…å®¹ï¼ˆç½‘é¡µ3æ–¹æ¡ˆæ‰©å±•ï¼‰
					if (child.nodeType === Node.TEXT_NODE) {
						obj["#text"] = (obj["#text"] || "") + childData;
					} else if (child.nodeType === Node.ELEMENT_NODE) {
						// è‡ªåŠ¨è½¬æ¢ä¸ºæ•°ç»„ï¼ˆåŒåæ ‡ç­¾å¤„ç†ï¼‰
						if (obj[childName]) {
							if (!Array.isArray(obj[childName])) {
								obj[childName] = [obj[childName]];
							}
							obj[childName].push(childData);
						} else {
							obj[childName] = childData;
						}
					}
				});

				// åˆå¹¶ç»“æœï¼ˆä¼˜å…ˆè¿”å›å†…å®¹æˆ–å¯¹è±¡ï¼‰
				return Object.keys(obj).length > 0 ? obj : null;
			}

			return traverse(xmlDoc.documentElement);
		}

		function xmlToJson88(xmlStr) {
			const parser = new DOMParser();
			const xmlDoc = parser.parseFromString(xmlStr, "text/xml");

			function traverse(node) {
				// å¤„ç†æ–‡æœ¬èŠ‚ç‚¹ï¼ˆç½‘é¡µ6æ–¹æ¡ˆï¼‰
				if (node.nodeType === Node.TEXT_NODE) {
					return node.textContent.trim();
				}

				const obj = {};

				// å¤„ç†å±æ€§ï¼ˆç½‘é¡µ3æ–¹æ¡ˆå¢å¼ºï¼‰
				if (node.attributes?.length > 0) {
					obj["@attributes"] = {};
					Array.from(node.attributes).forEach(attr => {
						obj["@attributes"][attr.name] = attr.value;
					});
				}

				// å¤„ç†å­èŠ‚ç‚¹ï¼ˆç½‘é¡µ7é€’å½’ç®—æ³•ï¼‰
				const childNodes = Array.from(node.childNodes);
				childNodes.forEach(child => {
					const childName = child.nodeName.toLowerCase();

					if (child.nodeType === Node.ELEMENT_NODE) {
						const childData = traverse(child);

						// è‡ªåŠ¨æ•°ç»„è½¬æ¢ï¼ˆç½‘é¡µ6æœ€ä½³å®è·µï¼‰
						if (obj[childName]) {
							if (!Array.isArray(obj[childName])) {
								obj[childName] = [obj[childName]];
							}
							obj[childName].push(childData);
						} else {
							obj[childName] = childData;
						}
					}
				});

				return Object.keys(obj).length ? obj : null;
			}

			return { [xmlDoc.documentElement.nodeName]: traverse(xmlDoc.documentElement) };
		}

		/**
		 * xmlå­—ç¬¦ä¸²è½¬æ¢xmlå¯¹è±¡æ•°æ®
		 * @param {Object} xmlStr
		 */
		function xmlStr2XmlObj(xmlStr) {
			var xmlObj = {};
			if (document.all) {
				var xmlDom = new ActiveXObject("Microsoft.XMLDOM");
				xmlDom.loadXML(xmlStr);
				xmlObj = xmlDom;
			} else {
				xmlObj = new DOMParser().parseFromString(xmlStr, "text/xml");
			}
			return xmlObj;
		}

		/**
		 * xmlå­—ç¬¦ä¸²è½¬æ¢jsonæ•°æ®
		 * @param {Object} xml
		 */
		function xmlObj2json(xml) {
			var xmlObj = xmlStr2XmlObj(xml);
			var jsonObj = {};
			if (xmlObj.childNodes.length > 0) {
				jsonObj = xml2json(xmlObj);
			}
			return jsonObj;
		}

		function parseElement(element) {
			let obj = {};
			if (element.nodeType === 1) { // Element
				if (element.attributes.length > 0) {
					obj['@attributes'] = {};
					for (let j = 0; j < element.attributes.length; j++) {
						let attribute = element.attributes.item(j);
						obj['@attributes'][attribute.nodeName] = attribute.nodeValue;
					}
				}
			} else if (element.nodeType === 3) { // Text
				obj = element.nodeValue;
			}

			if (element.hasChildNodes()) {
				for (let i = 0; i < element.childNodes.length; i++) {
					let item = element.childNodes.item(i);
					let nodeName = item.nodeName;
					if (typeof(obj[nodeName]) === 'undefined') {
						obj[nodeName] = parseElement(item);
					} else {
						if (typeof(obj[nodeName].push) === 'undefined') {
							let old = obj[nodeName];
							obj[nodeName] = [];
							obj[nodeName].push(old);
						}
						obj[nodeName].push(parseElement(item));
					}
				}
			}
			return obj;
		}

		function xmlToJson(xml) {
			const obj = {};

			// å¤„ç†å…ƒç´ èŠ‚ç‚¹
			if (xml.nodeType === Node.ELEMENT_NODE) {
				// å¤„ç†å±æ€§
				if (xml.attributes.length > 0) {
					obj["@attributes"] = {};
					Array.from(xml.attributes).forEach(attr => {
						obj["@attributes"][attr.name] = attr.value;
					});
				}

				// å¤„ç†å­èŠ‚ç‚¹
				Array.from(xml.childNodes).forEach(child => {
					const childObj = xmlToJson(child);
					const nodeName = child.nodeName;

					if (typeof obj[nodeName] === 'undefined') {
						obj[nodeName] = childObj;
					} else {
						if (!Array.isArray(obj[nodeName])) {
							obj[nodeName] = [obj[nodeName]];
						}
						obj[nodeName].push(childObj);
					}
				});

				return Object.keys(obj).length > 0 ? obj : xml.textContent.trim();
			}

			// å¤„ç†æ–‡æœ¬èŠ‚ç‚¹
			if (xml.nodeType === Node.TEXT_NODE) {
				return xml.textContent.trim();
			}
		}

		function parseXML(xmlString) {
			const parser = new xml2js.Parser({
				explicitArray: false,
				mergeAttrs: true
			});

			parser.parseString(xmlString, (err, result) => {
				if(err) return console.error(err);
				console.log('æµè§ˆå™¨ç«¯JSON:', result);
			});
		}

		// XMLè½¬JSON
		function xmlToJson() {
			try {
				const xmlString = document.getElementById('xmlInput').value;
				// const parser = new DOMParser();
				// const xmlDoc = parser.parseFromString(xmlString, "xml/text");
				//
				// const xmlobj = xmlStr2XmlObj(xmlDoc);
				// const jsonResult = xmlObj2json(xmlobj);
				//const json = parseElement(xmlDoc.documentElement);
				//const jsonResult = JSON.stringify(json, null, 2);
				const jsonObj = xmlToJson88(xmlString);
				document.getElementById('jsonInput').value = JSON.stringify(jsonObj, null, 4);

				showError('');
			} catch (error) {
				showError('è½¬æ¢é”™è¯¯: ' + error.message);
			}
		}

		// æ ¸å¿ƒè½¬æ¢å‡½æ•°ï¼ˆæ”¯æŒç‰¹æ®Šå­—ç¬¦ç¼–ç ï¼‰
		function jsonToXml(jsonObj, rootName = 'root', indent = '') {
			let xml = '';
			const encodeName = (name) => {
				return name.replace(/[^a-zA-Z0-9_-]/g, c =>
						`_x${c.charCodeAt(0).toString(16).padStart(4, '0').toUpperCase()}_`);
			};

			// å¤„ç†æ•°ç»„
			if (Array.isArray(jsonObj)) {
				jsonObj.forEach((item, index) => {
					xml += `${indent}<${encodeName(rootName)}>\n`;
					xml += jsonToXml(item, 'item', indent + '  ');
					xml += `${indent}</${encodeName(rootName)}>\n`;
				});
				return xml;
			}

			// å¤„ç†å¯¹è±¡
			if (typeof jsonObj === 'object') {
				const attrs = jsonObj["@attributes"] || {};
				const children = Object.entries(jsonObj)
						.filter(([k]) => k !== "@attributes");

				const startTag = `${indent}<${encodeName(rootName)}` +
						Object.entries(attrs)
								.map(([k, v]) => ` ${encodeName(k)}="${v}"`)
								.join('') +
						'>\n';

				xml += startTag;

				children.forEach(([key, value]) => {
					if (value === null || value === undefined) return;

					if (typeof value === 'object') {
						xml += jsonToXml(value, key, indent + '  ');
					} else {
						xml += `${indent}  <${encodeName(key)}>`;
						xml += escapeXml(value.toString());
						xml += `</${encodeName(key)}>\n`;
					}
				});

				xml += `${indent}</${encodeName(rootName)}>\n`;
				return xml;
			}

			// å¤„ç†åŸå§‹å€¼
			return `${indent}<${encodeName(rootName)}>${escapeXml(jsonObj)}</${encodeName(rootName)}>\n`;
		}

		// XMLç‰¹æ®Šå­—ç¬¦è½¬ä¹‰
		function escapeXml(unsafe) {
			return unsafe.replace(/[<>&'"]/g, c =>
					({ '<': '&lt;', '>': '&gt;', '&': '&amp;', "'": '&apos;', '"': '&quot;' })[c]);
		}

		// è½¬æ¢å…¥å£
		function convertJsonToXml() {
			try {
				const jsonString = document.getElementById('jsonInput').value;
				const jsonObj = JSON.parse(jsonString);
				const rootKey = Object.keys(jsonObj)[0] || 'root';
				const xmlHeader = `<?xml version="1.0" encoding="UTF-8"?>\n`;
				const formattedXml = xmlHeader + jsonToXml(jsonObj[rootKey], rootKey);

				document.getElementById('xmlInput').value = formattedXml;
				showError('');
			} catch (error) {
				showError(`è½¬æ¢é”™è¯¯: ${error.message}`);
			}
		}

		// XMLæ ¼å¼åŒ–
		function formatXml(xml) {
			let formatted = '';
			let indent = '';
			const tokens = xml.split(/(<[^>]+>)/g);

			tokens.forEach(token => {
				if (token.startsWith('<')) {
					if (token.startsWith('</')) {
						indent = indent.slice(4);
						formatted += '\n' + indent + token;
					} else {
						formatted += '\n' + indent + token;
						if (!token.startsWith('<?xml') && !token.endsWith('/>')) {
							indent += '    ';
						}
					}
				} else {
					formatted += token;
				}
			});

			return formatted.trim();
		}

		// è¾…åŠ©åŠŸèƒ½
		function clearAll() {
			document.getElementById('xmlInput').value = '';
			document.getElementById('jsonInput').value = '';
			showError('');
			updateLineNumbers('xmlInput', 'xmlLines');
			updateLineNumbers('jsonInput', 'jsonLines');
		}

		function showError(message) {
			const errorElem = document.getElementById('errorMsg');
			errorElem.textContent = message;
			errorElem.style.display = message ? 'block' : 'none';
		}

		// åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
		document.querySelectorAll('textarea').forEach(ta => {
			ta.addEventListener('input', function() {
				const isXml = this.id === 'xmlInput';
				updateLineNumbers(this.id, isXml ? 'xmlLines' : 'jsonLines');
			});
			ta.dispatchEvent(new Event('input'));
		});
	</script>
</div>
</body>

</html>